import { Test, runTests, assertEquals } from "../junit";
import {Charset, CharsetName, Charsets, StringBuilder} from "../../src/util/string";

// START Test Charsets

const TEST_STRING = `EnQR © わさび Codes 2024 😊`;

const EXPECTED_ENCODINGS: { [k: string]: Uint8Array } = {
    "US_ASCII": new Uint8Array([
        0x45, 0x6E, 0x51, 0x52, 0x20, 0x3F, 0x20, 0x3F, 0x3F, 0x3F, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x73, 0x20, 0x32, 0x30,
        0x32, 0x34, 0x20, 0x3F, 0x3F
    ]),
    "ISO_8859_1": new Uint8Array([
        0x45, 0x6E, 0x51, 0x52, 0x20, 0xA9, 0x20, 0x3F, 0x3F, 0x3F, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x73, 0x20, 0x32, 0x30,
        0x32, 0x34, 0x20, 0x3F, 0x3F
    ]),
    "UTF_8": new Uint8Array([
        0x45, 0x6E, 0x51, 0x52, 0x20, 0xC2, 0xA9, 0x20, 0xE3, 0x82, 0x8F, 0xE3, 0x81, 0x95, 0xE3, 0x81, 0xB3, 0x20, 0x43,
        0x6F, 0x64, 0x65, 0x73, 0x20, 0x32, 0x30, 0x32, 0x34, 0x20, 0xF0, 0x9F, 0x98, 0x8A
    ]),
    "UTF_16BE": new Uint8Array([
        0x00, 0x45, 0x00, 0x6E, 0x00, 0x51, 0x00, 0x52, 0x00, 0x20, 0x00, 0xA9, 0x00, 0x20, 0x30, 0x8F, 0x30, 0x55, 0x30,
        0x73, 0x00, 0x20, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x32, 0x00, 0x30,
        0x00, 0x32, 0x00, 0x34, 0x00, 0x20, 0xD8, 0x3D, 0xDE, 0x0A
    ]),
    "UTF_16LE": new Uint8Array([
        0x45, 0x00, 0x6E, 0x00, 0x51, 0x00, 0x52, 0x00, 0x20, 0x00, 0xA9, 0x00, 0x20, 0x00, 0x8F, 0x30, 0x55, 0x30, 0x73,
        0x30, 0x20, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x32, 0x00, 0x30, 0x00,
        0x32, 0x00, 0x34, 0x00, 0x20, 0x00, 0x3D, 0xD8, 0x0A, 0xDE
    ]),
    // UTF_16 intentionally missing
    "SHIFT_JIS": new Uint8Array([
        0x45, 0x6E, 0x51, 0x52, 0x20, 0x3F, 0x20, 0x82, 0xED, 0x82, 0xB3, 0x82, 0xD1, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x73,
        0x20, 0x32, 0x30, 0x32, 0x34, 0x20, 0x3F
    ]),
    /*
    "GB2312": new Uint8Array([
        0x45, 0x6E, 0x51, 0x52, 0x20, 0x3F, 0x20, 0xA4, 0xEF, 0xA4, 0xB5, 0xA4, 0xD3, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x73,
        0x20, 0x32, 0x30, 0x32, 0x34, 0x20, 0x3F
    ]),
    "EUC_JP": new Uint8Array([
        0x45, 0x6E, 0x51, 0x52, 0x20, 0x8F, 0xA2, 0xED, 0x20, 0xA4, 0xEF, 0xA4, 0xB5, 0xA4, 0xD3, 0x20, 0x43, 0x6F, 0x64,
        0x65, 0x73, 0x20, 0x32, 0x30, 0x32, 0x34, 0x20, 0x3F
    ]),
    */
};

function testCharset(charset: Charset) {
    const { name } = charset;
    const checkBOM: boolean = name === "UTF_16";

    test(name, () => {
        let encoded: Uint8Array = charset.encode(TEST_STRING);

        let expected: Uint8Array;
        if (checkBOM) {
            const hi: number = encoded[0];
            const lo: number = encoded[1];
            const le: boolean = (hi === 0xFF);
            expect(le ? lo : hi).toEqual(0xFE);
            expected = EXPECTED_ENCODINGS[le ? "UTF_16LE" : "UTF_16BE"];
            encoded = encoded.subarray(2);
        } else {
            expected = EXPECTED_ENCODINGS[name];
        }

        expect(expected).not.toBeUndefined();
        expect(encoded.length).toEqual(expected.length);
        for (let i=0; i < encoded.length; i++) {
            expect(encoded[i]).toEqual(expected[i]);
        }
    });
}

describe("Charsets", () => {
    let cs: Charset;
    for (let k of Object.keys(Charsets)) {
        cs = Charsets[k as CharsetName];
        testCharset(cs);
    }
});

// START Test StringBuilder

class StringBuilderTest {

    @Test()
    basic() {
        const sb = new StringBuilder();
        sb.append("Test")
            .appendSpace()
            .append(73)
            .appendNewline();

        sb.appendString("テスト")
            .appendSpace()
            .appendDigit(7)
            .appendDigit(3)
            .appendChar(10);

        const str = sb.toString();
        const expected: string = `Test 73\nテスト 73\n`;
        assertEquals(expected, str);
    }

    @Test()
    veryBig() {
        const sb = new StringBuilder();
        for (let i=0; i < 4096; i++) {
            let s: string = i.toString(16);
            for (let i=s.length; i < 3; i++) sb.appendDigit(0);
            sb.append(s);
        }

        const out = sb.toString();
        const size: number = 4096 * 3;
        assertEquals(size, out.length);

        let i: number = 0;
        let z: number = 0;
        while (i < size) {
            let hex: string = out[i++] + out[i++] + out[i++];
            assertEquals(z++, parseInt(hex, 16));
        }
    }

}
runTests(StringBuilderTest);
